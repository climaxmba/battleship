/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/modules/battleship.worker.js":
/*!******************************************!*\
  !*** ./src/modules/battleship.worker.js ***!
  \******************************************/
/***/ (() => {

eval("onmessage = (e) => {\r\n  postMessage(getBestSquare(e.data));\r\n};\r\n\r\nfunction getBestSquare(board) {\r\n  // Add function or compatibility\r\n  board.__proto__.getAdjSquares = (square) => {\r\n    return board.board.get(square).adjSquares;\r\n  };\r\n\r\n  let bestSquares = [],\r\n    maxProb = -Infinity,\r\n    probMap = calcProbMap(board);\r\n\r\n  // Group squares with the highest values together\r\n  for (const square of probMap.keys()) {\r\n    if (probMap.get(square) > maxProb) {\r\n      bestSquares = [square];\r\n      maxProb = probMap.get(square);\r\n    } else if (probMap.get(square) === maxProb) {\r\n      bestSquares.push(square);\r\n    }\r\n  }\r\n\r\n  // Return a random square with the highest probability\r\n  return bestSquares[Math.floor(Math.random() * bestSquares.length)];\r\n}\r\n\r\nfunction calcProbMap(board) {\r\n  let probMap = new Map();\r\n\r\n  for (let x = 0; x < 10; x++) {\r\n    for (let y = 0; y < 10; y++) {\r\n      probMap.set(`${x},${y}`, 0);\r\n    }\r\n  }\r\n\r\n  board.ships.forEach((shipObj) => {\r\n    if (!shipObj.ship.length <= shipObj.ship.hits) {\r\n      board.board.forEach((_val, pos) => {\r\n        const vertical = canExistShip(board, pos, shipObj.ship.length, true),\r\n          horizontal = canExistShip(board, pos, shipObj.ship.length, false);\r\n\r\n        if (vertical)\r\n          vertical.forEach((pos) => probMap.set(pos, probMap.get(pos) + 1));\r\n        if (horizontal)\r\n          horizontal.forEach((pos) => probMap.set(pos, probMap.get(pos) + 1));\r\n        const hits = [...board.ships].flatMap((shipObj) => [\r\n          ...shipObj.hitCoords,\r\n        ]);\r\n        hits.forEach((hit) => {\r\n          [...board.getAdjSquares(hit)]\r\n            .filter((obj) => {\r\n              const square = obj.square;\r\n              if (\r\n                `${parseInt(hit[0]) + 1},${parseInt(hit[2]) + 1}` === square ||\r\n                `${parseInt(hit[0]) - 1},${parseInt(hit[2]) - 1}` === square ||\r\n                `${parseInt(hit[0]) + 1},${parseInt(hit[2]) - 1}` === square ||\r\n                `${parseInt(hit[0]) - 1},${parseInt(hit[2]) + 1}` === square\r\n              )\r\n                return false;\r\n              else return true;\r\n            })\r\n            .forEach((obj) => {\r\n              const square = obj.square;\r\n              if (!hits.includes(square) && !board.missedAttacks.has(square)) {\r\n                if (\r\n                  hits.includes(`${parseInt(square[0]) + 2},${square[2]}`) ||\r\n                  hits.includes(`${parseInt(square[0]) - 2},${square[2]}`) ||\r\n                  hits.includes(`${square[0]},${parseInt(square[2]) + 2}`) ||\r\n                  hits.includes(`${square[0]},${parseInt(square[2]) - 2}`)\r\n                )\r\n                  probMap.set(square, probMap.get(square) + 5); //Increase probability in the direction of the ship\r\n                probMap.set(square, probMap.get(square) + 1);\r\n              }\r\n            });\r\n        });\r\n      });\r\n    }\r\n  });\r\n\r\n  return probMap;\r\n}\r\n\r\nfunction canExistShip(board, pos, shipLength, isVertical = false) {\r\n  const area = [];\r\n  for (let i = 0; i < shipLength; i++) {\r\n    if (isVertical) {\r\n      area.push(`${pos[0]},${parseInt(pos[2]) + i}`);\r\n    } else {\r\n      area.push(`${parseInt(pos[0]) + i},${pos[2]}`);\r\n    }\r\n  }\r\n\r\n  if (!validateAreas([area])) return false;\r\n\r\n  const hitAreas = [...board.ships].flatMap((shipObj) => [\r\n    ...shipObj.hitCoords,\r\n  ]);\r\n  try {\r\n    area.forEach((pos) => {\r\n      if (board.missedAttacks.has(pos) || hitAreas.includes(pos))\r\n        throw new Error();\r\n    });\r\n  } catch {\r\n    return false;\r\n  }\r\n\r\n  return area;\r\n}\r\n\r\nfunction validateAreas(areasList) {\r\n  const p = new WorkerPlayer();\r\n  try {\r\n    areasList.forEach((area) => {\r\n      if (!p.addShip(area)) throw new Error();\r\n    });\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nclass WorkerShip {\r\n  length;\r\n  hits = 0;\r\n\r\n  constructor(length) {\r\n    this.length = length;\r\n  }\r\n\r\n  hit() {\r\n    this.hits++;\r\n  }\r\n  isSunk() {\r\n    return this.length <= this.hits;\r\n  }\r\n}\r\n\r\nclass WorkerGameBoard {\r\n  board = new Map();\r\n  ships = new Set();\r\n  missedAttacks = new Set();\r\n\r\n  constructor() {\r\n    this.#initBoard();\r\n  }\r\n\r\n  addSquare(square) {\r\n    this.board.set(square, { square, adjSquares: new Set() });\r\n  }\r\n\r\n  connectSquare(square1, square2) {\r\n    if (this.board.has(square1) && this.board.has(square2)) {\r\n      this.board.get(square1).adjSquares.add(this.board.get(square2));\r\n      this.board.get(square2).adjSquares.add(this.board.get(square1));\r\n    }\r\n  }\r\n\r\n  getAdjSquares(square) {\r\n    return this.board.get(square).adjSquares;\r\n  }\r\n\r\n  getAvailableSquares() {\r\n    const boardSquares = [...this.board.keys()],\r\n      shipPosAttacked = [...this.ships].flatMap((obj) => [...obj.hitCoords]);\r\n    const squareSet = boardSquares.filter(\r\n      (square) =>\r\n        !(this.missedAttacks.has(square) || shipPosAttacked.includes(square))\r\n    );\r\n\r\n    return [...squareSet];\r\n  }\r\n\r\n  #initBoard() {\r\n    // Add squares\r\n    for (let i = 0; i < 10; i++) {\r\n      for (let j = 0; j < 10; j++) {\r\n        this.addSquare(`${i},${j}`);\r\n      }\r\n    }\r\n\r\n    // Connect squares\r\n    for (let i = 0; i < 10; i++) {\r\n      for (let j = 0; j < 10; j++) {\r\n        const currPos = `${i},${j}`;\r\n        this.connectSquare(currPos, `${i + 1},${j}`);\r\n        this.connectSquare(currPos, `${i - 1},${j}`);\r\n        this.connectSquare(currPos, `${i},${j + 1}`);\r\n        this.connectSquare(currPos, `${i},${j - 1}`);\r\n        this.connectSquare(currPos, `${i + 1},${j + 1}`);\r\n        this.connectSquare(currPos, `${i - 1},${j - 1}`);\r\n        this.connectSquare(currPos, `${i + 1},${j - 1}`);\r\n        this.connectSquare(currPos, `${i - 1},${j + 1}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  isValidPos(pos) {\r\n    if (!this.board.has(pos)) return false;\r\n\r\n    const list = [...this.ships].flatMap((obj) => [...obj.coords]);\r\n    if (list.includes(pos)) return false;\r\n\r\n    const adjPos = [...this.board.get(pos).adjSquares].map((obj) => obj.square);\r\n\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (adjPos.includes(list[i])) return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nclass WorkerPlayer {\r\n  gameBoard;\r\n\r\n  constructor() {\r\n    this.gameBoard = new WorkerGameBoard();\r\n  }\r\n\r\n  addShip(area) {\r\n    if (this.#isValidArea(area)) {\r\n      this.gameBoard.ships.add({\r\n        ship: new WorkerShip(area.length),\r\n        coords: new Set(area),\r\n        hitCoords: new Set(),\r\n      });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  #isValidArea(area) {\r\n    // Verify that all coordinates in area are adjacent...\r\n    // ...and not diagonal\r\n    for (let i = 0; i < area.length; i++) {\r\n      if (area[i + 1]) {\r\n        const currPos = area[i].split(\",\"),\r\n          nextPos = area[i + 1].split(\",\");\r\n        if (\r\n          !(\r\n            parseInt(currPos[0]) + 1 == nextPos[0] ||\r\n            parseInt(currPos[0]) - 1 == nextPos[0] ||\r\n            parseInt(currPos[0]) + 1 == nextPos[1] ||\r\n            parseInt(currPos[0]) - 1 == nextPos[1] ||\r\n            parseInt(currPos[1]) + 1 == nextPos[0] ||\r\n            parseInt(currPos[1]) - 1 == nextPos[0] ||\r\n            parseInt(currPos[1]) + 1 == nextPos[1] ||\r\n            parseInt(currPos[1]) - 1 == nextPos[1]\r\n          ) ||\r\n          [parseInt(currPos[0]) + 1, parseInt(currPos[1]) + 1].toString() ===\r\n            area[i + 1] ||\r\n          [parseInt(currPos[0]) - 1, parseInt(currPos[1]) - 1].toString() ===\r\n            area[i + 1] ||\r\n          [parseInt(currPos[0]) + 1, parseInt(currPos[1]) - 1].toString() ===\r\n            area[i + 1] ||\r\n          [parseInt(currPos[0]) - 1, parseInt(currPos[1]) + 1].toString() ===\r\n            area[i + 1]\r\n        )\r\n          return false;\r\n      }\r\n    }\r\n    return area.every(this.gameBoard.isValidPos.bind(this.gameBoard));\r\n  }\r\n\r\n  randomSquare(board) {\r\n    const avalableSquares = board.getAvailableSquares();\r\n    return avalableSquares[Math.floor(Math.random() * avalableSquares.length)];\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://battleship/./src/modules/battleship.worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/modules/battleship.worker.js"]();
/******/ 	
/******/ })()
;